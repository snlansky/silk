#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Empty {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    /// Header types 0-10000 are reserved and defined by HeaderType
    #[prost(int32, tag = "1")]
    pub header_type: i32,
    #[prost(int32, tag = "2")]
    pub version: i32,
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::std::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub channel_id: std::string::String,
    #[prost(string, tag = "5")]
    pub tx_id: std::string::String,
    /// If mutual TLS is employed, this represents
    /// the hash of the client's TLS certificate
    #[prost(bytes, tag = "6")]
    pub tls_cert_hash: std::vec::Vec<u8>,
    /// Creator of the message, a marshaled msp.SerializedIdentity
    #[prost(bytes, tag = "7")]
    pub creator: std::vec::Vec<u8>,
    /// Arbitrary number that may only be used once. Can be used to detect replay attacks.
    #[prost(bytes, tag = "8")]
    pub nonce: std::vec::Vec<u8>,
}
/// Payload is the message contents (and header to allow for signing)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    /// Header is included to provide identity and prevent replay
    #[prost(message, optional, tag = "1")]
    pub header: ::std::option::Option<Header>,
    /// Data, the encoding of which is defined by the type in the header
    #[prost(bytes, tag = "2")]
    pub data: std::vec::Vec<u8>,
}
/// Envelope wraps a Payload with a signature so that the message may be authenticated
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Envelope {
    /// A marshaled Payload
    #[prost(bytes, tag = "1")]
    pub payload: std::vec::Vec<u8>,
    /// A signature by the creator specified in the Payload header
    #[prost(bytes, tag = "2")]
    pub signature: std::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Unknown = 0,
    Success = 200,
    BadRequest = 400,
    Forbidden = 403,
    NotFound = 404,
    RequestEntityTooLarge = 413,
    InternalServerError = 500,
    NotImplemented = 501,
    ServiceUnavailable = 503,
}
///-------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HeaderType {
    /// Used for messages which query contract.proto
    Query = 0,
    /// Used for messages which invoke contract.proto
    Invoke = 1,
    /// Used for messages which express create the channel
    CreateChannel = 2,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedProposal {
    /// The bytes of Proposal
    #[prost(bytes, tag = "1")]
    pub proposal_bytes: std::vec::Vec<u8>,
    /// Signature over proposalBytes; this signature is to be verified against
    /// the creator identity contained in the header of the Proposal message
    /// marshaled as proposalBytes
    #[prost(bytes, tag = "2")]
    pub signature: std::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Proposal {
    /// The header of the proposal. It is the bytes of the Header
    #[prost(message, optional, tag = "1")]
    pub header: ::std::option::Option<Header>,
    /// The payload of the proposal as defined by the type in the proposal
    /// ContractProposalPayload bytes
    #[prost(bytes, tag = "2")]
    pub payload: std::vec::Vec<u8>,
}
///-------- the Contract Proposal -----------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractProposalPayload {
    #[prost(message, optional, tag = "1")]
    pub contract_id: ::std::option::Option<ContractId>,
    #[prost(message, optional, tag = "2")]
    pub input: ::std::option::Option<ContractInput>,
    #[prost(map = "string, bytes", tag = "3")]
    pub transient_map: ::std::collections::HashMap<std::string::String, std::vec::Vec<u8>>,
    #[prost(int32, tag = "4")]
    pub timeout: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractId {
    ///all other requests will use the name (really a hashcode) generated by
    ///the deploy transaction
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Carries the contract function and its arguments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractInput {
    #[prost(bytes, repeated, tag = "1")]
    pub args: ::std::vec::Vec<std::vec::Vec<u8>>,
    #[prost(map = "string, bytes", tag = "2")]
    pub decorations: ::std::collections::HashMap<std::string::String, std::vec::Vec<u8>>,
    /// is_init is used for the application to signal that an invocation is to be routed
    /// to the legacy 'Init' function for compatibility with contracts which handled
    /// Init in the old way.  New applications should manage their initialized state
    /// themselves.
    #[prost(bool, tag = "3")]
    pub is_init: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractEvent {
    #[prost(string, tag = "1")]
    pub contract: std::string::String,
    #[prost(string, tag = "2")]
    pub tx_id: std::string::String,
    #[prost(string, tag = "3")]
    pub event_name: std::string::String,
    #[prost(bytes, tag = "4")]
    pub payload: std::vec::Vec<u8>,
}
/// A ProposalResponse is returned from an endorser to the proposal submitter.
/// The idea is that this message contains the endorser's response to the
/// request of a client to perform an action over a chaincode (or more
/// generically on the ledger); the response might be success/error (conveyed in
/// the Response field) together with a description of the action and a
/// signature over it by that endorser.  If a sufficient number of distinct
/// endorsers agree on the same action and produce signature to that effect, a
/// transaction can be generated and sent for ordering.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalResponse {
    /// Version indicates message protocol version
    #[prost(int32, tag = "1")]
    pub version: i32,
    /// Timestamp is the time that the message
    /// was created as  defined by the sender
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::std::option::Option<::prost_types::Timestamp>,
    /// A response message indicating whether the
    /// endorsement of the action was successful
    #[prost(message, optional, tag = "4")]
    pub response: ::std::option::Option<Response>,
    /// The payload of response. It is the bytes of ProposalResponsePayload
    #[prost(bytes, tag = "5")]
    pub payload: std::vec::Vec<u8>,
    /// The endorsement of the proposal, basically
    /// the endorser's signature over the payload
    #[prost(message, optional, tag = "6")]
    pub endorsement: ::std::option::Option<Endorsement>,
}
/// A response with a representation similar to an HTTP response that can
/// be used within another message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    /// A status code that should follow the HTTP status codes.
    #[prost(int32, tag = "1")]
    pub status: i32,
    /// A message associated with the response code.
    #[prost(string, tag = "2")]
    pub message: std::string::String,
    /// A payload that can be used to include metadata with this response.
    #[prost(bytes, tag = "3")]
    pub payload: std::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalResponsePayload {
    /// This field contains the read set and the write set produced by the
    /// contract executing this invocation.
    #[prost(bytes, tag = "1")]
    pub results: std::vec::Vec<u8>,
    /// This field contains the events generated by the contract executing this
    /// invocation.
    #[prost(bytes, tag = "2")]
    pub events: std::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Endorsement {
    /// Identity of the endorser (e.g. its certificate)
    #[prost(bytes, tag = "1")]
    pub endorser: std::vec::Vec<u8>,
    /// Signature of the payload included in ProposalResponse concatenated with
    /// the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
    #[prost(bytes, tag = "2")]
    pub signature: std::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchSubmit {
    #[prost(message, repeated, tag = "1")]
    pub signed_proposal_list: ::std::vec::Vec<SignedProposal>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchResponse {
    #[prost(message, repeated, tag = "1")]
    pub proposal_response_list: ::std::vec::Vec<ProposalResponse>,
}
/// This is finalized block structure to be shared among the orderer and peer
/// Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
/// in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
/// the Metadata is not.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag = "1")]
    pub header: ::std::option::Option<BlockHeader>,
    #[prost(message, optional, tag = "2")]
    pub data: ::std::option::Option<BlockData>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::std::option::Option<BlockMetadata>,
}
/// BlockHeader is the element of the block which forms the block chain
/// The block header is hashed using the configured chain hashing algorithm
/// over the ASN.1 encoding of the BlockHeader
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    /// The position in the blockchain
    #[prost(uint64, tag = "1")]
    pub number: u64,
    /// The hash of the previous block header
    #[prost(bytes, tag = "2")]
    pub previous_hash: std::vec::Vec<u8>,
    /// The hash of the BlockData, by MerkleTree
    #[prost(bytes, tag = "3")]
    pub data_hash: std::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockData {
    #[prost(bytes, repeated, tag = "1")]
    pub data: ::std::vec::Vec<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockMetadata {
    #[prost(bytes, repeated, tag = "1")]
    pub metadata: ::std::vec::Vec<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(enumeration = "message::MessageType", tag = "1")]
    pub message_type: i32,
    /// The identifier used to correlate response messages to their related
    /// request messages.  correlation_id should be set to a random string
    /// for messages which are not responses to previously sent messages.  For
    /// response messages, correlation_id should be set to the same string as
    /// contained in the request message.
    #[prost(string, tag = "2")]
    pub correlation_id: std::string::String,
    /// The content of the message, defined by message_type.  In many
    /// cases, this data has been serialized with Protocol Buffers
    #[prost(bytes, tag = "3")]
    pub content: std::vec::Vec<u8>,
}
pub mod message {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MessageType {
        Default = 0,
        /// Consensus message
        ConsensusRegister = 100,
        Unregister = 101,
        /// Contract message
        ContractRegister = 110,
        /// peer -> contract
        ContractTransaction = 111,
        /// contract request get state
        ContractGetStateRequest = 112,
        ContractGetStateResponse = 113,
        /// contract request put state
        ContractPutStateRequest = 114,
        /// contract request delete state
        ContractDelStateRequest = 115,
        /// contract -> peer
        ContractTransactionCompletedRequest = 116,
        /// Peer message
        PeerHandshakeRequest = 200,
        PeerHandshakeResponse = 201,
        PeerHeartbeatRequest = 202,
        PeerHeartbeatResponse = 203,
        PeerBroadcastTransaction = 204,
        PeerBroadcastBlockTracker = 205,
        /// pull blocks from other peer nodes
        PeerDeliverBlock = 206,
        /// Consensus notification messages
        ConsensusTransactionArrived = 300,
        ConsensusNotifyBlockCommit = 301,
        ConsensusChainDescribe = 302,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unregister {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusRegister {
    #[prost(string, tag = "1")]
    pub alg: std::string::String,
    #[prost(map = "string, bytes", tag = "2")]
    pub decorations: ::std::collections::HashMap<std::string::String, std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusChainDescribe {
    #[prost(string, tag = "1")]
    pub chain: std::string::String,
    #[prost(message, optional, tag = "2")]
    pub header: ::std::option::Option<BlockHeader>,
}
#[doc = r" Generated client implementations."]
pub mod consensus_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    pub struct ConsensusClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConsensusClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConsensusClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        pub async fn register(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Message>,
        ) -> Result<tonic::Response<tonic::codec::Streaming<super::Message>>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Consensus/Register");
            self.inner
                .streaming(request.into_streaming_request(), path, codec)
                .await
        }
    }
    impl<T: Clone> Clone for ConsensusClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod consensus_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ConsensusServer."]
    #[async_trait]
    pub trait Consensus: Send + Sync + 'static {
        #[doc = "Server streaming response type for the Register method."]
        type RegisterStream: Stream<Item = Result<super::Message, tonic::Status>>
            + Send
            + Sync
            + 'static;
        async fn register(
            &self,
            request: tonic::Request<tonic::Streaming<super::Message>>,
        ) -> Result<tonic::Response<Self::RegisterStream>, tonic::Status>;
    }
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ConsensusServer<T: Consensus> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: Consensus> ConsensusServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T: Consensus> Service<http::Request<HyperBody>> for ConsensusServer<T> {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<HyperBody>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/protos.Consensus/Register" => {
                    struct RegisterSvc<T: Consensus>(pub Arc<T>);
                    impl<T: Consensus> tonic::server::StreamingService<super::Message> for RegisterSvc<T> {
                        type Response = super::Message;
                        type ResponseStream = T::RegisterStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Message>>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.register(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1;
                        let inner = inner.0;
                        let method = RegisterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: Consensus> Clone for ConsensusServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: Consensus> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Consensus> tonic::transport::NamedService for ConsensusServer<T> {
        const NAME: &'static str = "protos.Consensus";
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractRegister {
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    #[prost(map = "string, bytes", tag = "2")]
    pub decorations: ::std::collections::HashMap<std::string::String, std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractTransaction {
    #[prost(message, optional, tag = "1")]
    pub proposal: ::std::option::Option<Proposal>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateRequest {
    #[prost(string, tag = "1")]
    pub key: std::string::String,
    #[prost(string, tag = "2")]
    pub channel_id: std::string::String,
    #[prost(string, tag = "3")]
    pub tx_id: std::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateResponse {
    #[prost(bytes, tag = "1")]
    pub value: std::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutStateRequest {
    #[prost(string, tag = "1")]
    pub key: std::string::String,
    #[prost(bytes, tag = "2")]
    pub value: std::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub channel_id: std::string::String,
    #[prost(string, tag = "4")]
    pub tx_id: std::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelStateRequest {
    #[prost(string, tag = "1")]
    pub key: std::string::String,
    #[prost(string, tag = "3")]
    pub channel_id: std::string::String,
    #[prost(string, tag = "4")]
    pub tx_id: std::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionCompleted {
    #[prost(message, optional, tag = "1")]
    pub proposal: ::std::option::Option<Proposal>,
    #[prost(message, optional, tag = "2")]
    pub response: ::std::option::Option<Response>,
    #[prost(message, optional, tag = "3")]
    pub event: ::std::option::Option<ContractEvent>,
}
#[doc = r" Generated client implementations."]
pub mod contract_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    pub struct ContractClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContractClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContractClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        pub async fn register(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Message>,
        ) -> Result<tonic::Response<tonic::codec::Streaming<super::Message>>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Contract/Register");
            self.inner
                .streaming(request.into_streaming_request(), path, codec)
                .await
        }
    }
    impl<T: Clone> Clone for ContractClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod contract_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ContractServer."]
    #[async_trait]
    pub trait Contract: Send + Sync + 'static {
        #[doc = "Server streaming response type for the Register method."]
        type RegisterStream: Stream<Item = Result<super::Message, tonic::Status>>
            + Send
            + Sync
            + 'static;
        async fn register(
            &self,
            request: tonic::Request<tonic::Streaming<super::Message>>,
        ) -> Result<tonic::Response<Self::RegisterStream>, tonic::Status>;
    }
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ContractServer<T: Contract> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: Contract> ContractServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T: Contract> Service<http::Request<HyperBody>> for ContractServer<T> {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<HyperBody>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/protos.Contract/Register" => {
                    struct RegisterSvc<T: Contract>(pub Arc<T>);
                    impl<T: Contract> tonic::server::StreamingService<super::Message> for RegisterSvc<T> {
                        type Response = super::Message;
                        type ResponseStream = T::RegisterStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Message>>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.register(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1;
                        let inner = inner.0;
                        let method = RegisterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: Contract> Clone for ContractServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: Contract> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Contract> tonic::transport::NamedService for ContractServer<T> {
        const NAME: &'static str = "protos.Contract";
    }
}
/// KVRWSet encapsulates the read-write set for a chaincode that operates upon a KV or Document data model
/// This structure is used for both the public data and the private data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvrwSet {
    #[prost(message, repeated, tag = "1")]
    pub reads: ::std::vec::Vec<KvRead>,
    #[prost(message, repeated, tag = "2")]
    pub range_queries_info: ::std::vec::Vec<RangeQueryInfo>,
    #[prost(message, repeated, tag = "3")]
    pub writes: ::std::vec::Vec<KvWrite>,
    #[prost(message, repeated, tag = "4")]
    pub metadata_writes: ::std::vec::Vec<KvMetadataWrite>,
}
/// HashedRWSet encapsulates hashed representation of a private read-write set for KV or Document data model
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HashedRwSet {
    #[prost(message, repeated, tag = "1")]
    pub hashed_reads: ::std::vec::Vec<KvReadHash>,
    #[prost(message, repeated, tag = "2")]
    pub hashed_writes: ::std::vec::Vec<KvWriteHash>,
    #[prost(message, repeated, tag = "3")]
    pub metadata_writes: ::std::vec::Vec<KvMetadataWriteHash>,
}
/// KVRead captures a read operation performed during transaction simulation
/// A 'nil' version indicates a non-existing key read by the transaction
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvRead {
    #[prost(string, tag = "1")]
    pub key: std::string::String,
    #[prost(message, optional, tag = "2")]
    pub version: ::std::option::Option<Version>,
}
/// KVWrite captures a write (update/delete) operation performed during transaction simulation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvWrite {
    #[prost(string, tag = "1")]
    pub key: std::string::String,
    #[prost(bool, tag = "2")]
    pub is_delete: bool,
    #[prost(bytes, tag = "3")]
    pub value: std::vec::Vec<u8>,
}
/// KVMetadataWrite captures all the entries in the metadata associated with a key
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvMetadataWrite {
    #[prost(string, tag = "1")]
    pub key: std::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::std::vec::Vec<KvMetadataEntry>,
}
/// KVReadHash is similar to the KVRead in spirit. However, it captures the hash of the key instead of the key itself
/// version is kept as is for now. However, if the version also needs to be privacy-protected, it would need to be the
/// hash of the version and hence of 'bytes' type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvReadHash {
    #[prost(bytes, tag = "1")]
    pub key_hash: std::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub version: ::std::option::Option<Version>,
}
/// KVWriteHash is similar to the KVWrite. It captures a write (update/delete) operation performed during transaction simulation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvWriteHash {
    #[prost(bytes, tag = "1")]
    pub key_hash: std::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub is_delete: bool,
    #[prost(bytes, tag = "3")]
    pub value_hash: std::vec::Vec<u8>,
}
/// KVMetadataWriteHash captures all the upserts to the metadata associated with a key hash
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvMetadataWriteHash {
    #[prost(bytes, tag = "1")]
    pub key_hash: std::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::std::vec::Vec<KvMetadataEntry>,
}
/// KVMetadataEntry captures a 'name'ed entry in the metadata of a key/key-hash.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvMetadataEntry {
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    #[prost(bytes, tag = "2")]
    pub value: std::vec::Vec<u8>,
}
/// Version encapsulates the version of a Key
/// A version of a committed key is maintained as the height of the transaction that committed the key.
/// The height is represenetd as a tuple <blockNum, txNum> where the txNum is the position of the transaction
/// (starting with 0) within block
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(uint64, tag = "1")]
    pub block_num: u64,
    #[prost(uint64, tag = "2")]
    pub tx_num: u64,
}
/// RangeQueryInfo encapsulates the details of a range query performed by a transaction during simulation.
/// This helps protect transactions from phantom reads by varifying during validation whether any new items
/// got committed within the given range between transaction simuation and validation
/// (in addition to regular checks for updates/deletes of the existing items).
/// readInfo field contains either the KVReads (for the items read by the range query) or a merkle-tree hash
/// if the KVReads exceeds a pre-configured numbers
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeQueryInfo {
    #[prost(string, tag = "1")]
    pub start_key: std::string::String,
    #[prost(string, tag = "2")]
    pub end_key: std::string::String,
    #[prost(bool, tag = "3")]
    pub itr_exhausted: bool,
    #[prost(oneof = "range_query_info::ReadsInfo", tags = "4, 5")]
    pub reads_info: ::std::option::Option<range_query_info::ReadsInfo>,
}
pub mod range_query_info {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ReadsInfo {
        #[prost(message, tag = "4")]
        RawReads(super::QueryReads),
        #[prost(message, tag = "5")]
        ReadsMerkleHashes(super::QueryReadsMerkleSummary),
    }
}
/// QueryReads encapsulates the KVReads for the items read by a transaction as a result of a query execution
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReads {
    #[prost(message, repeated, tag = "1")]
    pub kv_reads: ::std::vec::Vec<KvRead>,
}
/// QueryReadsMerkleSummary encapsulates the Merkle-tree hashes for the QueryReads
/// This allows to reduce the size of RWSet in the presence of query results
/// by storing certain hashes instead of actual results.
/// maxDegree field refers to the maximum number of children in the tree at any level
/// maxLevel field contains the lowest level which has lesser nodes than maxDegree (starting from leaf level)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReadsMerkleSummary {
    #[prost(uint32, tag = "1")]
    pub max_degree: u32,
    #[prost(uint32, tag = "2")]
    pub max_level: u32,
    #[prost(bytes, repeated, tag = "3")]
    pub max_level_hashes: ::std::vec::Vec<std::vec::Vec<u8>>,
}
#[doc = r" Generated client implementations."]
pub mod endorser_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " process message from client"]
    pub struct EndorserClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EndorserClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EndorserClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        pub async fn process_proposal(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchSubmit>,
        ) -> Result<tonic::Response<super::BatchResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Endorser/ProcessProposal");
            self.inner.unary(request.into_request(), path, codec).await
        }
        pub async fn ping(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> Result<tonic::Response<super::Empty>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Endorser/Ping");
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for EndorserClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
}
#[doc = r" Generated client implementations."]
pub mod p2p_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " send and receive message to other peer nodes"]
    pub struct P2pClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl P2pClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> P2pClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        pub async fn broadcast(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Message>,
        ) -> Result<tonic::Response<tonic::codec::Streaming<super::Message>>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.P2P/Broadcast");
            self.inner
                .streaming(request.into_streaming_request(), path, codec)
                .await
        }
    }
    impl<T: Clone> Clone for P2pClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod endorser_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with EndorserServer."]
    #[async_trait]
    pub trait Endorser: Send + Sync + 'static {
        async fn process_proposal(
            &self,
            request: tonic::Request<super::BatchSubmit>,
        ) -> Result<tonic::Response<super::BatchResponse>, tonic::Status>;
        async fn ping(
            &self,
            request: tonic::Request<super::Empty>,
        ) -> Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    #[doc = " process message from client"]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct EndorserServer<T: Endorser> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: Endorser> EndorserServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T: Endorser> Service<http::Request<HyperBody>> for EndorserServer<T> {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<HyperBody>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/protos.Endorser/ProcessProposal" => {
                    struct ProcessProposalSvc<T: Endorser>(pub Arc<T>);
                    impl<T: Endorser> tonic::server::UnaryService<super::BatchSubmit> for ProcessProposalSvc<T> {
                        type Response = super::BatchResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchSubmit>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.process_proposal(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ProcessProposalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/protos.Endorser/Ping" => {
                    struct PingSvc<T: Endorser>(pub Arc<T>);
                    impl<T: Endorser> tonic::server::UnaryService<super::Empty> for PingSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<super::Empty>) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.ping(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = PingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: Endorser> Clone for EndorserServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: Endorser> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Endorser> tonic::transport::NamedService for EndorserServer<T> {
        const NAME: &'static str = "protos.Endorser";
    }
}
#[doc = r" Generated server implementations."]
pub mod p2p_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with P2pServer."]
    #[async_trait]
    pub trait P2p: Send + Sync + 'static {
        #[doc = "Server streaming response type for the Broadcast method."]
        type BroadcastStream: Stream<Item = Result<super::Message, tonic::Status>>
            + Send
            + Sync
            + 'static;
        async fn broadcast(
            &self,
            request: tonic::Request<tonic::Streaming<super::Message>>,
        ) -> Result<tonic::Response<Self::BroadcastStream>, tonic::Status>;
    }
    #[doc = " send and receive message to other peer nodes"]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct P2pServer<T: P2p> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: P2p> P2pServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T: P2p> Service<http::Request<HyperBody>> for P2pServer<T> {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<HyperBody>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/protos.P2P/Broadcast" => {
                    struct BroadcastSvc<T: P2p>(pub Arc<T>);
                    impl<T: P2p> tonic::server::StreamingService<super::Message> for BroadcastSvc<T> {
                        type Response = super::Message;
                        type ResponseStream = T::BroadcastStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Message>>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.broadcast(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1;
                        let inner = inner.0;
                        let method = BroadcastSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: P2p> Clone for P2pServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: P2p> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: P2p> tonic::transport::NamedService for P2pServer<T> {
        const NAME: &'static str = "protos.P2P";
    }
}
/// TxReadWriteSet encapsulates a read-write set for a transaction
/// DataModel specifies the enum value of the data model
/// ns_rwset field specifies a list of chaincode specific read-write set (one for each chaincode)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxReadWriteSet {
    #[prost(enumeration = "tx_read_write_set::DataModel", tag = "1")]
    pub data_model: i32,
    #[prost(message, repeated, tag = "2")]
    pub ns_rwset: ::std::vec::Vec<NsReadWriteSet>,
}
pub mod tx_read_write_set {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DataModel {
        Kv = 0,
    }
}
/// NsReadWriteSet encapsulates the read-write set for a chaincode
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NsReadWriteSet {
    #[prost(string, tag = "1")]
    pub namespace: std::string::String,
    /// Data model specific serialized proto message (e.g., kvrwset.KVRWSet for KV and Document data models)
    #[prost(bytes, tag = "2")]
    pub rwset: std::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub collection_hashed_rwset: ::std::vec::Vec<CollectionHashedReadWriteSet>,
}
/// CollectionHashedReadWriteSet encapsulate the hashed representation for the private read-write set for a collection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionHashedReadWriteSet {
    #[prost(string, tag = "1")]
    pub collection_name: std::string::String,
    /// Data model specific serialized proto message (e.g., kvrwset.HashedRWSet for KV and Document data models)
    #[prost(bytes, tag = "2")]
    pub hashed_rwset: std::vec::Vec<u8>,
    /// Hash of entire private read-write set for a specific collection. This helps in authenticating the private read-write set efficiently
    #[prost(bytes, tag = "3")]
    pub pvt_rwset_hash: std::vec::Vec<u8>,
}
/// TxPvtReadWriteSet encapsulate the private read-write set for a transaction
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxPvtReadWriteSet {
    #[prost(enumeration = "tx_read_write_set::DataModel", tag = "1")]
    pub data_model: i32,
    #[prost(message, repeated, tag = "2")]
    pub ns_pvt_rwset: ::std::vec::Vec<NsPvtReadWriteSet>,
}
/// NsPvtReadWriteSet encapsulates the private read-write set for a chaincode
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NsPvtReadWriteSet {
    #[prost(string, tag = "1")]
    pub namespace: std::string::String,
    #[prost(message, repeated, tag = "2")]
    pub collection_pvt_rwset: ::std::vec::Vec<CollectionPvtReadWriteSet>,
}
/// CollectionPvtReadWriteSet encapsulates the private read-write set for a collection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionPvtReadWriteSet {
    #[prost(string, tag = "1")]
    pub collection_name: std::string::String,
    /// Data model specific serialized proto message (e.g., kvrwset.KVRWSet for KV and Document data models)
    #[prost(bytes, tag = "2")]
    pub rwset: std::vec::Vec<u8>,
}
/// KV -- QueryResult for range/execute query. Holds a key and corresponding value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Kv {
    #[prost(string, tag = "1")]
    pub namespace: std::string::String,
    #[prost(string, tag = "2")]
    pub key: std::string::String,
    #[prost(bytes, tag = "3")]
    pub value: std::vec::Vec<u8>,
}
/// KeyModification -- QueryResult for history query. Holds a transaction ID, value,
/// timestamp, and delete marker which resulted from a history query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyModification {
    #[prost(string, tag = "1")]
    pub tx_id: std::string::String,
    #[prost(bytes, tag = "2")]
    pub value: std::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::std::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "4")]
    pub is_delete: bool,
}
/// ProcessedTransaction wraps an Envelope that includes a transaction along with an indication
/// of whether the transaction was validated or invalidated by committing peer.
/// The use case is that get_transaction_by_id API needs to retrieve the transaction Envelope
/// from block storage, and return it to a client, and indicate whether the transaction
/// was validated or invalidated by committing peer. So that the originally submitted
/// transaction Envelope is not modified, the ProcessedTransaction wrapper is returned.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessedTransaction {
    /// An Envelope which includes a processed transaction
    #[prost(message, optional, tag = "1")]
    pub transaction_envelope: ::std::option::Option<Envelope>,
    /// An indication of whether the transaction was validated or invalidated by committing peer
    #[prost(int32, tag = "2")]
    pub validation_code: i32,
}
/// The transaction to be sent to the ordering service. A transaction contains
/// one or more ProposalResponse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(message, optional, tag = "1")]
    pub signed_proposal: ::std::option::Option<SignedProposal>,
    #[prost(message, repeated, tag = "2")]
    pub response: ::std::vec::Vec<ProposalResponse>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TxValidationCode {
    Valid = 0,
    NilEnvelope = 1,
    BadPayload = 2,
    BadCommonHeader = 3,
    BadCreatorSignature = 4,
    InvalidEndorserTransaction = 5,
    InvalidConfigTransaction = 6,
    UnsupportedTxPayload = 7,
    BadProposalTxid = 8,
    DuplicateTxid = 9,
    EndorsementPolicyFailure = 10,
    MvccReadConflict = 11,
    PhantomReadConflict = 12,
    UnknownTxType = 13,
    TargetChainNotFound = 14,
    MarshalTxError = 15,
    NilTxaction = 16,
    ExpiredChaincode = 17,
    ChaincodeVersionConflict = 18,
    BadHeaderExtension = 19,
    BadChannelHeader = 20,
    BadResponsePayload = 21,
    BadRwset = 22,
    IllegalWriteset = 23,
    InvalidWriteset = 24,
    InvalidChaincode = 25,
    NotValidated = 254,
    InvalidOtherReason = 255,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionedValueProto {
    #[prost(bytes, tag = "1")]
    pub version_bytes: std::vec::Vec<u8>,
    #[prost(bytes, tag = "2")]
    pub value: std::vec::Vec<u8>,
    #[prost(bytes, tag = "3")]
    pub metadata: std::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionedHeight {
    #[prost(uint64, tag = "1")]
    pub block_num: u64,
    #[prost(uint64, tag = "2")]
    pub tx_num: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockchainInfo {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    #[prost(bytes, tag = "2")]
    pub current_block_hash: std::vec::Vec<u8>,
    #[prost(bytes, tag = "3")]
    pub previous_block_hash: std::vec::Vec<u8>,
}
